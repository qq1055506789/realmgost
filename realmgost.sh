#!/bin/bash`n`n# 增强版 Realm & GOST 一键管理脚本`n# 功能：支持多条转发规则、备注管理、状态查看`n# 版本：v2.7`n# 修改说明：`n#   1. 修复GOST域名解析问题（启动时预解析为IP）`n#   2. 统一Realm和GOST的地址处理逻辑`n#   3. 增强错误处理和日志提示`n#   4. 添加临时文件清理`n#   5. 使用 ss 替代 netstat`n#   6. 改进服务配置逻辑（空配置时停止并禁用服务）`n#   7. 移除不必要的错误抑制`n`n# 颜色定义`nRED='\033[0;31m'`nGREEN='\033[0;32m'`nYELLOW='\033[1;33m'`nBLUE='\033[0;34m'`nPURPLE='\033[0;35m'`nCYAN='\033[0;36m'`nNC='\033[0m' # No Color`n`n# 配置文件路径`nCONFIG_DIR="/etc/forward_tools"`nREALM_CONFIG="$CONFIG_DIR/realm_rules.conf"`nGOST_CONFIG="$CONFIG_DIR/gost_rules.conf"`nNOTES_CONFIG="$CONFIG_DIR/forward_notes.conf"`n`n# 检查root权限`ncheck_root() {`n    if [ "$(id -u)" != "0" ]; then`n        echo -e "${RED}错误：此脚本必须以root权限运行！${NC}" >&2`n        exit 1`n    fi`n}`n`n# 检查系统`ncheck_system() {`n    if [ -f /etc/os-release ]; then`n        . /etc/os-release`n        SYSTEM=$ID`n    elif type lsb_release >/dev/null 2>&1; then`n        SYSTEM=$(lsb_release -si | tr '[:upper:]' '[:lower:]')`n    elif [ -f /etc/lsb-release ]; then`n        . /etc/lsb-release`n        SYSTEM=$DISTRIB_ID | tr '[:upper:]' '[:lower:]'`n    elif [ -f /etc/debian_version ]; then`n        SYSTEM="debian"`n    elif [ -f /etc/redhat-release ]; then`n        SYSTEM="centos" # 或考虑更具体的如 fedora`n    else`n        SYSTEM=$(uname -s | tr '[:upper:]' '[:lower:]')`n    fi`n`n    case "$SYSTEM" in`n        ubuntu|debian)`n            PKG_MANAGER="apt-get"`n            DNS_UTILS="dnsutils"`n            IP_ROUTE_PKG="iproute2"`n            ;;`n        centos|rhel|fedora)`n            PKG_MANAGER="yum"`n            if [ -f /usr/bin/dnf ]; then`n                PKG_MANAGER="dnf"`n            fi`n            DNS_UTILS="bind-utils"`n            IP_ROUTE_PKG="iproute"`n            ;;`n        *)`n            echo -e "${RED}不支持的系统: $SYSTEM！请手动安装依赖。${NC}"`n            # 尝试继续，但可能失败`n            PKG_MANAGER="echo" # 防止后续命令出错`n            DNS_UTILS="dnsutils"`n            IP_ROUTE_PKG="iproute2"`n            ;;`n    esac`n}`n`n# 安装依赖`ninstall_dependencies() {`n    echo -e "${YELLOW}正在安装必要依赖...${NC}"`n    if [ "$PKG_MANAGER" = "apt-get" ]; then`n        $PKG_MANAGER update`n    fi`n    $PKG_MANAGER install -y wget unzip curl tar jq $DNS_UTILS $IP_ROUTE_PKG`n`n    local missing_deps=()`n    command -v wget &> /dev/null || missing_deps+=("wget")`n    command -v jq &> /dev/null || missing_deps+=("jq")`n    command -v dig &> /dev/null || missing_deps+=("dig ($DNS_UTILS)")`n    command -v ss &> /dev/null || missing_deps+=("ss ($IP_ROUTE_PKG)")`n`n    if [ ${#missing_deps[@]} -ne 0 ]; then`n        echo -e "${RED}以下依赖安装失败或未找到，请手动安装后重试: ${missing_deps[*]}${NC}"`n        exit 1`n    fi`n    echo -e "${GREEN}依赖安装完成。${NC}"`n}`n`n# 初始化配置目录`ninit_config_dir() {`n    mkdir -p "$CONFIG_DIR"`n    touch "$REALM_CONFIG" "$GOST_CONFIG" "$NOTES_CONFIG"`n    chmod 600 "$REALM_CONFIG" "$GOST_CONFIG" "$NOTES_CONFIG"`n}`n`n# 清理临时文件`ncleanup_temp_files() {`n    rm -f /tmp/realm.tar.gz /tmp/realm /tmp/gost.tar.gz /tmp/gost_*`n    # 尝试删除可能的解压目录`n    find /tmp -maxdepth 1 -name "gost_*" -type d -exec rm -rf {} + 2>/dev/null`n}`n`n# 安装Realm`ninstall_realm() {`n    if command -v realm &> /dev/null; then`n        echo -e "${YELLOW}Realm 已安装，跳过安装步骤。${NC}"`n        return`n    fi`n`n    echo -e "${YELLOW}正在安装Realm...${NC}"`n    local latest_version=$(curl -s https://api.github.com/repos/zhboner/realm/releases/latest | grep 'tag_name' | cut -d\" -f4)`n`n    if [ -z "$latest_version" ]; then`n        echo -e "${RED}无法获取Realm最新版本！${NC}"`n        cleanup_temp_files`n        exit 1`n    fi`n`n    local download_url="https://github.com/zhboner/realm/releases/download/${latest_version}/realm-x86_64-unknown-linux-gnu.tar.gz"`n`n    echo "正在下载: $download_url"`n    if ! wget --progress=bar:force -O /tmp/realm.tar.gz "$download_url" 2>&1 | grep --line-buffered "%" | sed -u -e "s,\.,,g" | awk '{printf("\b\b\b\b%4s", $2)}'; then`n        echo -e "\n${RED}下载Realm失败！${NC}"`n        cleanup_temp_files`n        exit 1`n    fi`n    echo -e "\n下载完成。"`n`n    echo "正在解压..."`n    if ! tar -xzf /tmp/realm.tar.gz -C /tmp; then`n        echo -e "${RED}解压Realm失败！${NC}"`n        cleanup_temp_files`n        exit 1`n    fi`n`n    mv /tmp/realm /usr/local/bin/realm`n    chmod +x /usr/local/bin/realm`n`n    if ! command -v realm &> /dev/null; then`n        echo -e "${RED}Realm安装失败！${NC}"`n        cleanup_temp_files`n        exit 1`n    fi`n`n    cleanup_temp_files`n    echo -e "${GREEN}Realm安装成功！版本: $latest_version${NC}"`n}`n`n# 安装GOST`ninstall_gost() {`n    if command -v gost &> /dev/null; then`n        echo -e "${YELLOW}GOST 已安装，跳过安装步骤。${NC}"`n        return`n    fi`n`n    echo -e "${YELLOW}正在安装GOST...${NC}"`n    # 尝试从API获取直接的下载链接`n    local release_info=$(curl -s https://api.github.com/repos/ginuerzh/gost/releases/latest)`n    local latest_version=$(echo "$release_info" | grep 'tag_name' | cut -d\" -f4)`n`n    if [ -z "$latest_version" ]; then`n        echo -e "${RED}无法获取GOST最新版本！${NC}"`n        cleanup_temp_files`n        exit 1`n    fi`n`n    local arch=$(uname -m)`n    case $arch in`n        x86_64) arch_suffix="amd64" ;;`n        aarch64) arch_suffix="arm64" ;;`n        *) echo -e "${RED}不支持的架构: $arch${NC}"; cleanup_temp_files; exit 1 ;;`n    esac`n`n    local download_url=$(echo "$release_info" | jq -r ".assets[] | select(.name | contains(\"linux_${arch_suffix}.tar.gz\")) | .browser_download_url")`n`n    if [ -z "$download_url" ]; then`n        # 如果API没有直接链接，则回退到拼接URL`n        echo -e "${YELLOW}无法从API获取直接下载链接，尝试拼接URL...${NC}"`n        download_url="https://github.com/ginuerzh/gost/releases/download/${latest_version}/gost-linux-${arch_suffix}-${latest_version#v}.tar.gz"`n        # 检查另一种可能的命名格式`n        if ! curl -s --head "$download_url" | head -n 1 | grep "200 OK" > /dev/null; then`n             download_url="https://github.com/ginuerzh/gost/releases/download/${latest_version}/gost_${latest_version#v}_linux_${arch_suffix}.tar.gz"`n        fi`n    fi`n`n`n    echo "正在下载: $download_url"`n    if ! wget --progress=bar:force -O /tmp/gost.tar.gz "$download_url" 2>&1 | grep --line-buffered "%" | sed -u -e "s,\.,,g" | awk '{printf("\b\b\b\b%4s", $2)}'; then`n        echo -e "\n${RED}下载GOST失败！尝试的URL: $download_url ${NC}"`n        cleanup_temp_files`n        exit 1`n    fi`n     echo -e "\n下载完成。"`n`n    echo "正在解压..."`n    if ! tar -xzf /tmp/gost.tar.gz -C /tmp; then`n         echo -e "${RED}解压GOST失败！${NC}"`n         cleanup_temp_files`n         exit 1`n    fi`n`n    # 查找解压后的gost可执行文件`n    local gost_executable=$(find /tmp -maxdepth 2 -name gost -type f -executable 2>/dev/null | head -n 1)`n`n    if [ -z "$gost_executable" ]; then`n        echo -e "${RED}无法在解压文件中找到GOST可执行文件！${NC}"`n        cleanup_temp_files`n        exit 1`n    fi`n`n    mv "$gost_executable" /usr/local/bin/gost`n    chmod +x /usr/local/bin/gost`n`n    if ! command -v gost &> /dev/null; then`n        echo -e "${RED}GOST安装失败！${NC}"`n        cleanup_temp_files`n        exit 1`n    fi`n`n    cleanup_temp_files`n    echo -e "${GREEN}GOST安装成功！版本: $latest_version${NC}"`n}`n`n# 解析域名获取IP地址`nresolve_domain() {`n    local domain=$1`n    local ip=$(dig +short "$domain" | head -n1)`n    `n    if [ -z "$ip" ]; then`n        echo -e "${RED}无法解析域名: $domain${NC}"`n        return 1`n    fi`n    `n    echo "$ip"`n}`n`n# 验证端口和地址格式`nvalidate_input() {`n    local port=$1`n    local addr=$2`n    `n    # 验证端口`n    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then`n        echo -e "${RED}错误：端口号必须是1-65535之间的数字！${NC}"`n        return 1`n    fi`n    `n    # 分离地址和端口`n    local remote_host=${addr%:*}`n    local remote_port=${addr##*:}`n    `n    # 验证远程端口`n    if ! [[ "$remote_port" =~ ^[0-9]+$ ]] || [ "$remote_port" -lt 1 ] || [ "$remote_port" -gt 65535 ]; then`n        echo -e "${RED}错误：远程端口号必须是1-65535之间的数字！${NC}"`n        return 1`n    fi`n    `n    # 验证远程主机`n    if [[ "$remote_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then`n        return 0  # 是IP地址`n    elif [[ "$remote_host" =~ ^[a-zA-Z0-9.-]+$ ]]; then`n        # 是域名，尝试解析`n        if ! resolve_domain "$remote_host" >/dev/null; then`n            return 1`n        fi`n        return 0`n    else`n        echo -e "${RED}错误：远程地址格式应为 IP:端口 或 域名:端口！${NC}"`n        return 1`n    fi`n}`n`n# 添加转发规则`nadd_forward_rule() {`n    local tool=$1`n    local local_port=$2`n    local remote_addr=$3`n    local note=$4`n    `n    # 验证输入`n    if ! validate_input "$local_port" "$remote_addr"; then`n        return 1`n    fi`n    `n    case $tool in`n        realm|gost)`n            config_file="$CONFIG_DIR/${tool}_rules.conf"`n            if grep -q "^$local_port " "$config_file"; then`n                echo -e "${RED}错误：端口 $local_port 的转发规则已存在！${NC}"`n                return 1`n            fi`n            echo "$local_port $remote_addr" >> "$config_file"`n            ;;`n        *)`n            echo -e "${RED}未知工具: $tool${NC}"`n            return 1`n            ;;`n    esac`n    `n    # 添加备注`n    if [ -n "$note" ]; then`n        echo "$tool $local_port $remote_addr $note" >> "$NOTES_CONFIG"`n    fi`n    `n    echo -e "${GREEN}成功添加 $tool 转发规则: 本地端口 $local_port -> $remote_addr${NC}"`n    if [ -n "$note" ]; then`n        echo -e "${CYAN}备注: $note${NC}"`n    fi`n}`n`n# 删除转发规则`ndelete_forward_rule() {`n    local tool=$1`n    local local_port=$2`n    `n    case $tool in`n        realm|gost)`n            config_file="$CONFIG_DIR/${tool}_rules.conf"`n            if ! grep -q "^$local_port " "$config_file"; then`n                echo -e "${RED}错误：找不到端口 $local_port 的转发规则！${NC}"`n                return 1`n            fi`n            sed -i "/^$local_port /d" "$config_file"`n            sed -i "/^$tool $local_port /d" "$NOTES_CONFIG"`n            ;;`n        *)`n            echo -e "${RED}未知工具: $tool${NC}"`n            return 1`n            ;;`n    esac`n    `n    echo -e "${GREEN}已删除 $tool 端口 $local_port 的转发规则${NC}"`n}`n`n# 更新备注`nupdate_note() {`n    local tool=$1`n    local local_port_to_update=$2 # Renamed to avoid conflict with loop var`n    local new_note=$3`n    local found_rule=0`n    local remote_addr=""`n`n    case $tool in`n        realm|gost)`n            config_file="$CONFIG_DIR/${tool}_rules.conf"`n            temp_notes_file=$(mktemp) # Create a temporary file for notes`n`n            # Read the config file to find the remote address for the given port`n            while IFS= read -r line || [[ -n "$line" ]]; do`n                [[ -z "$line" || "$line" =~ ^\s*# ]] && continue`n                local current_port current_remote rest`n                read -r current_port current_remote rest <<< "$line"`n                if [[ "$current_port" == "$local_port_to_update" ]]; then`n                    remote_addr="$current_remote"`n                    found_rule=1`n                    break # Found the rule, no need to read further`n                fi`n            done < "$config_file"`n`n            if [ $found_rule -eq 0 ]; then`n                echo -e "${RED}错误：在 ${config_file} 中找不到端口 $local_port_to_update 的 ${tool^^} 转发规则！${NC}"`n                rm -f "$temp_notes_file"`n                return 1`n            fi`n`n            # Process the notes file, excluding the old note for the target rule`n            if [ -f "$NOTES_CONFIG" ]; then`n                 while IFS= read -r note_line || [[ -n "$note_line" ]]; do`n                     local note_tool note_port rest_of_note`n                     read -r note_tool note_port rest_of_note <<< "$note_line"`n                     # Keep notes that don't match the tool and port being updated`n                     if [[ "$note_tool" != "$tool" || "$note_port" != "$local_port_to_update" ]]; then`n                         echo "$note_line" >> "$temp_notes_file"`n                     fi`n                 done < "$NOTES_CONFIG"`n            fi`n`n            # Add the new note if provided`n            if [ -n "$new_note" ]; then`n                echo "$tool $local_port_to_update $remote_addr $new_note" >> "$temp_notes_file"`n            fi`n`n            # Replace the old notes file with the temporary one`n            # Use cat and redirect to handle potential permission issues with mv`n            cat "$temp_notes_file" > "$NOTES_CONFIG"`n            rm -f "$temp_notes_file"`n            chmod 600 "$NOTES_CONFIG" # Ensure permissions are correct`n`n            if [ -n "$new_note" ]; then`n                 echo -e "${GREEN}已更新 $tool 端口 $local_port_to_update 的备注${NC}"`n            else`n                 echo -e "${GREEN}已删除 $tool 端口 $local_port_to_update 的备注${NC}"`n            fi`n            ;;`n        *)`n            echo -e "${RED}未知工具: $tool${NC}"`n            return 1`n            ;;`n    esac`n}`n`n# 生成Realm服务配置文件`ngenerate_realm_service() {`n    local config_file="$REALM_CONFIG"`n    local service_file="/etc/systemd/system/realm.service"`n`n    if [ ! -s "$config_file" ]; then`n        echo -e "${YELLOW}Realm配置文件为空或不存在，将停止并禁用服务。${NC}"`n        if systemctl is-active --quiet realm.service; then`n            systemctl stop realm.service`n        fi`n        if systemctl is-enabled --quiet realm.service; then`n            systemctl disable realm.service`n        fi`n        rm -f "$service_file"`n        systemctl daemon-reload`n        return 0 # 不是错误，是预期行为`n    fi`n`n`n    local cmd_args=""`n    local has_error=0`n`n    while IFS= read -r line || [[ -n "$line" ]]; do`n        # 跳过空行或注释行`n        [[ -z "$line" || "$line" =~ ^\s*# ]] && continue`n`n        # 使用 read 替代 awk`n        local local_port remote_addr rest`n        read -r local_port remote_addr rest <<< "$line"`n`n        # 验证一下读取的数据是否有效`n        if [ -z "$local_port" ] || [ -z "$remote_addr" ]; then`n             echo -e "${YELLOW}警告：跳过配置文件中的无效行: '$line'${NC}"`n             continue`n        fi`n`n`n        # 解析域名`n        local remote_host=${remote_addr%:*}`n        local remote_port=${remote_addr##*:}`n        if [[ ! "$remote_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then`n            local resolved_ip=$(resolve_domain "$remote_host")`n            if [ $? -ne 0 ]; then`n                 echo -e "${RED}错误：无法解析Realm规则中的域名 '$remote_host' (来自行: '$line')。请检查网络或域名。${NC}"`n                 has_error=1`n                 continue # 跳过此规则，但标记错误`n            fi`n            remote_addr="$resolved_ip:$remote_port"`n        fi`n`n        cmd_args+=" -l :$local_port -r $remote_addr"`n    done < "$config_file"`n`n    if [ $has_error -eq 1 ]; then`n        echo -e "${RED}由于域名解析错误，Realm服务配置未完成或部分完成。${NC}"`n        return 1`n    fi`n`n    if [ -z "$cmd_args" ]; then`n        echo -e "${YELLOW}没有有效的Realm规则生成，将停止并禁用服务。${NC}"`n        if systemctl is-active --quiet realm.service; then`n            systemctl stop realm.service`n        fi`n        if systemctl is-enabled --quiet realm.service; then`n            systemctl disable realm.service`n        fi`n        rm -f "$service_file"`n        systemctl daemon-reload`n        return 0`n    fi`n`n`n    cat > "$service_file" <<EOF`n[Unit]`nDescription=REALM Port Forwarding Service`nAfter=network.target`n`n[Service]`nType=simple`nUser=root`nExecStart=/usr/local/bin/realm$cmd_args`nRestart=always`nRestartSec=3`nStandardOutput=journal`nStandardError=journal`n`n[Install]`nWantedBy=multi-user.target`nEOF`n`n   chmod 644 "$service_file"`n   echo -e "${GREEN}Realm服务文件已生成/更新。${NC}"`n   return 0`n}`n`n# 生成GOST服务配置文件`ngenerate_gost_service() {`n    local config_file="$GOST_CONFIG"`n    local service_file="/etc/systemd/system/gost.service"`n`n    if [ ! -s "$config_file" ]; then`n        echo -e "${YELLOW}GOST配置文件为空或不存在，将停止并禁用服务。${NC}"`n        if systemctl is-active --quiet gost.service; then`n            systemctl stop gost.service`n        fi`n        if systemctl is-enabled --quiet gost.service; then`n            systemctl disable gost.service`n        fi`n        rm -f "$service_file"`n        systemctl daemon-reload`n        return 0`n    fi`n`n    local cmd_args=""`n    local has_error=0`n`n    while IFS= read -r line || [[ -n "$line" ]]; do`n        [[ -z "$line" || "$line" =~ ^\s*# ]] && continue`n`n        # 使用 read 替代 awk`n        local local_port remote_addr rest`n        read -r local_port remote_addr rest <<< "$line"`n`n        if [ -z "$local_port" ] || [ -z "$remote_addr" ]; then`n             echo -e "${YELLOW}警告：跳过配置文件中的无效行: '$line'${NC}"`n             continue`n        fi`n`n        # 解析域名`n        local remote_host=${remote_addr%:*}`n        local remote_port=${remote_addr##*:}`n        if [[ ! "$remote_host" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then`n            local resolved_ip=$(resolve_domain "$remote_host")`n            if [ $? -ne 0 ]; then`n                echo -e "${RED}错误：无法解析GOST规则中的域名 '$remote_host' (来自行: '$line')。请检查网络或域名。${NC}"`n                has_error=1`n                continue`n            fi`n            remote_addr="$resolved_ip:$remote_port"`n        fi`n`n        cmd_args+=" -L=tcp://:$local_port/$remote_addr"`n    done < "$config_file"`n`n    if [ $has_error -eq 1 ]; then`n        echo -e "${RED}由于域名解析错误，GOST服务配置未完成或部分完成。${NC}"`n        return 1`n    fi`n`n    if [ -z "$cmd_args" ]; then`n        echo -e "${YELLOW}没有有效的GOST规则生成，将停止并禁用服务。${NC}"`n        if systemctl is-active --quiet gost.service; then`n            systemctl stop gost.service`n        fi`n        if systemctl is-enabled --quiet gost.service; then`n            systemctl disable gost.service`n        fi`n        rm -f "$service_file"`n        systemctl daemon-reload`n        return 0`n    fi`n`n    cat > "$service_file" <<EOF`n[Unit]`nDescription=GOST Port Forwarding Service`nAfter=network.target`n`n[Service]`nType=simple`nUser=root`nExecStart=/usr/local/bin/gost$cmd_args`nRestart=always`nRestartSec=3`nStandardOutput=journal`nStandardError=journal`n`n[Install]`nWantedBy=multi-user.target`nEOF`n`n    chmod 644 "$service_file"`n    echo -e "${GREEN}GOST服务文件已生成/更新。${NC}"`n    return 0`n}`n`n# 配置服务`nconfigure_services() {`n    echo -e "${YELLOW}正在配置服务...${NC}"`n    local realm_success=0`n    local gost_success=0`n    local reload_needed=0`n`n    # 配置Realm`n    if generate_realm_service; then`n        if [ -f /etc/systemd/system/realm.service ]; then`n            systemctl enable realm.service`n            echo -e "${GREEN}Realm服务配置完成！${NC}"`n            realm_success=1`n            reload_needed=1`n        else`n            echo -e "${YELLOW}Realm服务未配置（无规则或已被移除）。${NC}"`n            realm_success=1 # 认为成功，因为是预期操作`n        fi`n    else`n        echo -e "${RED}Realm服务配置失败！${NC}"`n    fi`n`n    # 配置GOST`n    if generate_gost_service; then`n         if [ -f /etc/systemd/system/gost.service ]; then`n            systemctl enable gost.service`n            echo -e "${GREEN}GOST服务配置完成！${NC}"`n            gost_success=1`n            reload_needed=1`n        else`n            echo -e "${YELLOW}GOST服务未配置（无规则或已被移除）。${NC}"`n            gost_success=1 # 认为成功`n        fi`n    else`n        echo -e "${RED}GOST服务配置失败！${NC}"`n    fi`n`n    if [ $reload_needed -eq 1 ]; then`n        systemctl daemon-reload`n    fi`n`n    # 如果任一配置失败，则返回错误`n    if [ $realm_success -eq 0 ] || [ $gost_success -eq 0 ]; then`n        return 1`n    else`n        return 0`n    fi`n}`n`n# 启动服务`nstart_services() {`n    local success=1`n    for tool in realm gost; do`n        if [ -f "/etc/systemd/system/${tool}.service" ]; then`n            echo -e "${YELLOW}正在启动 ${tool} 服务...${NC}"`n            if systemctl start ${tool}.service; then`n                # 短暂等待确认服务是否稳定启动`n                sleep 1`n                if systemctl is-active --quiet ${tool}.service; then`n                    echo -e "${GREEN}${tool} 服务启动成功！${NC}"`n                else`n                    echo -e "${RED}${tool} 服务启动后未能保持活动状态！请检查日志。${NC}"`n                    journalctl -u ${tool}.service -n 10 --no-pager`n                    success=0`n                fi`n            else`n                echo -e "${RED}${tool} 服务启动命令执行失败！${NC}"`n                journalctl -u ${tool}.service -n 10 --no-pager`n                success=0`n            fi`n        elif [ -s "$CONFIG_DIR/${tool}_rules.conf" ]; then`n             # 如果有规则但服务文件不存在，说明配置阶段可能出错了`n             echo -e "${YELLOW}警告：${tool} 有规则但服务文件不存在，可能配置失败。${NC}"`n        fi`n    done`n    return $success`n}`n`n# 显示所有转发规则`nshow_all_rules() {`n    echo -e "\n${BLUE}====== 所有转发规则 ======${NC}"`n`n    for tool in realm gost; do`n        config_file="$CONFIG_DIR/${tool}_rules.conf"`n        if [ -s "$config_file" ]; then`n            echo -e "\n${PURPLE}${tool^^} 转发规则:${NC}"`n            while IFS= read -r line || [[ -n "$line" ]]; do # Handle last line without newline`n                 [[ -z "$line" || "$line" =~ ^\s*# ]] && continue`n`n                # 使用 read 替代 awk`n                local local_port remote_addr rest`n                read -r local_port remote_addr rest <<< "$line"`n`n                # 检查是否成功读取到端口和地址`n                if [ -z "$local_port" ] || [ -z "$remote_addr" ]; then`n                     echo -e "${YELLOW}警告：跳过配置文件中的格式错误行: '$line'${NC}"`n                     continue`n                fi`n`n                # 查找备注 - 使用 grep 仍然是查找备注较简单的方式`n                # 但确保 grep 查找的是以 tool 和 port 开头的行`n                local note=""`n                if [ -f "$NOTES_CONFIG" ]; then`n                    note=$(grep "^$tool $local_port " "$NOTES_CONFIG" | sed -e "s/^$tool $local_port $remote_addr //" -e "s/^$tool $local_port [^ ]* //") # 移除前缀以获取备注`n                fi`n`n                echo -e "本地端口: ${GREEN}$local_port${NC} -> 远程地址: ${GREEN}$remote_addr${NC}"`n                [ -n "$note" ] && echo -e "备注: ${CYAN}$note${NC}"`n                echo "------------------------"`n            done < "$config_file"`n        else`n            echo -e "\n${YELLOW}没有配置${tool^^}转发规则${NC}"`n        fi`n    done`n}`n`n# 显示服务状态`nshow_service_status() {`n    echo -e "\n${BLUE}====== 服务状态 ======${NC}"`n    for tool in realm gost; do`n        if [ -f "/etc/systemd/system/${tool}.service" ]; then`n            echo -e "\n${YELLOW}${tool^^} 服务状态:${NC}"`n            systemctl status ${tool}.service --no-pager -l`n        else`n             echo -e "\n${YELLOW}${tool^^} 服务未配置或已移除。${NC}"`n        fi`n    done`n`n    echo -e "\n${BLUE}====== 监听端口 (TCP/UDP) ======${NC}"`n    # 使用 ss 替代 netstat，更现代且通常默认安装`n    if command -v ss &> /dev/null; then`n        ss -tulnp | grep -E 'realm|gost' || echo -e "${YELLOW}未检测到 Realm 或 GOST 监听端口。${NC}"`n    else`n        echo -e "${RED}错误：无法找到 'ss' 命令。无法检查监听端口。${NC}"`n    fi`n}`n`n# 主菜单`nmain_menu() {`n    while true; do`n        # 清屏前先显示菜单，防止用户输入时界面跳动`n        clear`n        echo -e "\n${BLUE}====== Realm & GOST 管理脚本 (v2.7) ======${NC}"`n        echo "1) 安装/更新 转发工具"`n        echo "2) 添加转发规则"`n        echo "3) 删除转发规则"`n        echo "4) 更新规则备注"`n        echo "5) 查看所有规则"`n        echo "6) 查看服务状态"`n        echo "7) 启动所有服务"`n        echo "8) 停止所有服务"`n        echo "9) 重启所有服务"`n        echo "10) 卸载所有服务"`n        echo "0) 退出"`n        read -p "请输入选项(0-10): " choice`n`n        case $choice in`n            1) check_root; check_system; install_dependencies; init_config_dir; install_realm; install_gost ;;`n            2) add_rule_menu ;;`n            3) delete_rule_menu ;;`n            4) update_note_menu ;;`n            5) show_all_rules ;;`n            6) show_service_status ;;`n            7)`n                echo "正在尝试启动所有服务..."`n                if start_services; then`n                     echo -e "${GREEN}所有可配置的服务已尝试启动。${NC}"`n                else`n                     echo -e "${RED}部分服务启动失败，请检查上面的日志。${NC}"`n                fi`n                ;;`n            8)`n                echo "正在停止 Realm 服务..."`n                systemctl stop realm.service`n                echo "正在停止 GOST 服务..."`n                systemctl stop gost.service`n                echo -e "${GREEN}已尝试停止所有服务 (如果存在)。${NC}"`n                ;;`n            9)`n                echo "正在重启 Realm 服务..."`n                systemctl restart realm.service`n                echo "正在重启 GOST 服务..."`n                systemctl restart gost.service`n                 # 短暂等待确认服务是否稳定`n                sleep 1`n                echo -e "${GREEN}已尝试重启所有服务 (如果存在)。${NC}"`n                # 可以选择性地添加状态检查`n                show_service_status`n                ;;`n            10) uninstall_services ;;`n            0) echo -e "${GREEN}退出脚本。${NC}"; exit 0 ;;`n            *) echo -e "${RED}无效选项！${NC}" ;;`n        esac`n`n        # 在循环末尾等待用户确认，而不是在 case 内部`n        echo # 添加一个空行增加可读性`n        read -n 1 -s -r -p "按任意键继续..."`n        # 不需要 clear，因为循环开始时会清屏`n    done`n}`n`n# 卸载服务`nuninstall_services() {`n    read -p "确定要卸载Realm和GOST及其配置文件吗？这将删除所有规则！(y/n): " confirm`n    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then`n        echo -e "${YELLOW}操作已取消。${NC}"`n        return`n    fi`n`n    echo "正在停止服务..."`n    systemctl stop realm.service gost.service`n`n    echo "正在禁用服务..."`n    systemctl disable realm.service gost.service`n`n    echo "正在删除服务文件..."`n    rm -f /etc/systemd/system/realm.service /etc/systemd/system/gost.service`n`n    echo "正在删除可执行文件..."`n    rm -f /usr/local/bin/realm /usr/local/bin/gost`n`n    echo "正在删除配置文件目录..."`n    rm -rf "$CONFIG_DIR"`n`n    echo "正在重载 systemd..."`n    systemctl daemon-reload`n`n    echo "正在清理临时文件 (以防万一)..."`n    cleanup_temp_files`n`n    echo -e "${GREEN}已卸载Realm和GOST及相关配置！${NC}"`n}`n`n# 添加规则菜单`nadd_rule_menu() {`n    echo -e "\n${BLUE}====== 添加转发规则 ======${NC}"`n    echo "1) 添加Realm转发规则"`n    echo "2) 添加GOST转发规则"`n    echo "0) 返回主菜单"`n    read -p "请选择操作(0-2): " choice`n    `n    case $choice in`n        1|2)`n            tool=$([ "$choice" -eq 1 ] && echo "realm" || echo "gost")`n            while true; do`n                read -p "请输入本地监听端口: " local_port`n                read -p "请输入远程目标地址(格式: IP或域名:端口): " remote_addr`n                if validate_input "$local_port" "$remote_addr"; then break; fi`n            done`n            read -p "请输入备注(可选): " note`n            add_forward_rule "$tool" "$local_port" "$remote_addr" "$note"`n            # 添加规则后，重新配置并启动服务`n            echo "正在应用配置..."`n            if configure_services; then`n                echo "正在启动/重启相关服务..."`n                if start_services; then`n                    echo -e "${GREEN}服务配置和启动完成。${NC}"`n                else`n                    echo -e "${RED}服务配置完成但启动失败，请检查日志。${NC}"`n                fi`n            else`n                echo -e "${RED}服务配置失败，请检查错误信息。服务可能未运行或配置不正确。${NC}"`n            fi`n            ;;`n        0) return ;;`n        *) echo -e "${RED}无效选择！${NC}" ;;`n    esac`n}`n`n# 删除规则菜单`ndelete_rule_menu() {`n    echo -e "\n${BLUE}====== 删除转发规则 ======${NC}"`n    echo "1) 删除Realm转发规则"`n    echo "2) 删除GOST转发规则"`n    echo "0) 返回主菜单"`n    read -p "请选择操作(0-2): " choice`n    `n    case $choice in`n        1|2)`n            tool=$([ "$choice" -eq 1 ] && echo "realm" || echo "gost")`n            read -p "请输入要删除的本地端口: " local_port`n            # 先尝试删除规则`n            if delete_forward_rule "$tool" "$local_port"; then`n                # 删除成功后，重新配置并尝试重启`n                echo "正在应用配置..."`n                if configure_services; then`n                    echo "正在尝试重启 ${tool} 服务 (如果仍然存在)..."`n                    # 检查服务文件是否存在，因为configure_services可能已将其删除`n                    if [ -f "/etc/systemd/system/${tool}.service" ]; then`n                         if systemctl restart "${tool}.service"; then`n                              echo -e "${GREEN}${tool} 服务已重启。${NC}"`n                         else`n                              echo -e "${RED}${tool} 服务重启失败！请检查日志。${NC}"`n                              journalctl -u ${tool}.service -n 10 --no-pager`n                         fi`n                    else`n                         echo -e "${YELLOW}${tool} 服务已被禁用或移除（因为没有剩余规则）。${NC}"`n                    fi`n                else`n                     echo -e "${RED}应用配置失败！请检查之前的错误。${NC}"`n                fi`n            else`n                # 删除规则失败（例如端口不存在）`n                echo -e "${YELLOW}删除规则操作未执行或失败，未更改服务状态。${NC}"`n            fi`n            ;;`n        0) return ;;`n        *) echo -e "${RED}无效选择！${NC}" ;;`n    esac`n}`n`n# 更新备注菜单`nupdate_note_menu() {`n    echo -e "\n${BLUE}====== 更新备注 ======${NC}"`n    echo "1) 更新Realm规则备注"`n    echo "2) 更新GOST规则备注"`n    echo "0) 返回主菜单"`n    read -p "请选择操作(0-2): " choice`n`n    case $choice in`n        1|2)`n            tool=$([ "$choice" -eq 1 ] && echo "realm" || echo "gost")`n            read -p "请输入需要更新备注的本地端口: " local_port`n`n            # 检查规则是否存在`n            config_file="$CONFIG_DIR/${tool}_rules.conf"`n            if ! grep -q "^$local_port " "$config_file"; then`n                echo -e "${RED}错误：找不到端口 $local_port 的 ${tool^^} 转发规则！${NC}"`n                return # 直接返回，不继续执行`n            fi`n`n            read -p "请输入新的备注 (留空则删除备注): " new_note`n            update_note "$tool" "$local_port" "$new_note"`n            # 更新备注不需要重启服务，所以这里不需要调用 configure_services 或 restart`n            ;;`n        0) return ;;`n        *) echo -e "${RED}无效选择！${NC}" ;;`n    esac`n}`n`n# 主函数`nmain() {`n    check_root`n    check_system`n    init_config_dir`n    main_menu`n}`n`nmain`n